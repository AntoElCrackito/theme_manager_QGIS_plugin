# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThemeManagerDialog
                                 A QGIS plugin
 This plugin stands to be a theme manager. It allows you to select the layers you want to set up in the different themes in your projet as a checklist, showing up all themes at once.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-22
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Antoine BOYER
        email                : @
 ***************************************************************************/
"""

import os
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtCore
from qgis.core import QgsProject, QgsMapThemeCollection

# Charge le formulaire .ui généré dans Qt
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'theme_manager_dialog_base.ui'))

class ThemeManagerDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        super().__init__(parent)  # Initialise le QDialog (fenêtre interface utilisateur du plugin qui comprend tous les Q...)
        self.iface = iface        # Stocke l'interface QGIS pour accéder au modèle QGIS (iface)
        self.setupUi(self)        # Configure l'UI dans QGIS à partir du .ui produit dans Qt
        self.last_modified_theme = None  # Variable mémorisant le dernier thème modifié par l'utilisateur

        # Association du bouton de création d'un thème avec la méthode create_new_theme
        if hasattr(self, "btnCreateNewTheme"):
            self.btnCreateNewTheme.clicked.connect(self.create_new_theme)
        
        # Lien entre le bouton d'application du thème sélectionné et sa méthode
        if hasattr(self, "btnApplyTheme"):
            self.btnApplyTheme.clicked.connect(self.apply_selected_theme)

# Possibilité d'outrepasser ce bouton avec cette méthode qui vient appliquer directement le thème dès le changement de thème sélectionné dans la ComboBox
#   if hasattr(self, "comboThemes"):
#       self.comboThemes.currentIndexChanged.connect(self.apply_selected_theme)

        # Associe le fait que l'utilisateur clique sur un des boutons de filtrage des projets à afficher avec la méthode on_filter_changed
        if hasattr(self, "table_FilterAndSuppressThemes"):
            self.table_FilterAndSuppressThemes.itemChanged.connect(self.on_filter_changed)

        # Remplit les deux tables (filtre et gestion des couches par thèmes) à l'ouverture du plugin
        self.fill_theme_table()
        self.fill_theme_filter_table()

    def fill_theme_table(self):
        # Récupère les thèmes du projet
        theme_collection = QgsProject.instance().mapThemeCollection()
        all_themes = list(theme_collection.mapThemes())  # Liste de tous les noms de thèmes

        # Si la table de filtre existe (protection contre les bugs proposée par Copilot), ne renvoyer que les thèmes cochés, c'est-à-dire à afficher
        if hasattr(self, "table_FilterAndSuppressThemes"):
            selected_themes = []
            for row in range(self.table_FilterAndSuppressThemes.rowCount()):
                # Si la case est cochée, on ajoute ce thème à l'affichage des couches par thèmes
                if self.table_FilterAndSuppressThemes.item(row, 0).checkState() == QtCore.Qt.Checked:
                    selected_themes.append(self.table_FilterAndSuppressThemes.item(row, 1).text())
            # Si aucun thème n'est coché tous les thèmes sont renvoyés (même si ce n'est pas logique ça permet d'éviter qu'on ne se demande pourquoi rien n'est affiché)
            themes = selected_themes if selected_themes else all_themes
        else:
            themes = all_themes

        # Construction d'une liste d'items comprenant les groupes et les couches de l'arbre des couches (Panneau "Couche" de QGIS)
        items = []
        def add_items_rec(node, parent_id=None):
            for child in node.children():
                if child.nodeType() == child.NodeGroup:
                    group_id = child.name()
                    items.append((True, group_id, child.name(), parent_id))  # True = groupe
                    add_items_rec(child, group_id)
                elif child.nodeType() == child.NodeLayer:
                    items.append((False, child.layerId(), child.name(), parent_id))  # False = couche
        root = QgsProject.instance().layerTreeRoot()
        add_items_rec(root)

        # Prépare la table pour l'affichage des groupes/couches et des thèmes sélectionnés
        self.tableThemes.clear()
        self.tableThemes.setRowCount(len(items) + 1)  # +1 pour les boutons tout sélectionner par colonne
        self.tableThemes.setColumnCount(len(themes) + 2)  # +1 pour les boutons tout sélectionner par ligne
        self.tableThemes.setHorizontalHeaderLabels(["Groupe/Couche"] + themes) # Ici, la première colonne comprend tous les groupes et les couches du layerTree, 
        # il n'a pas de nom de colonne, il est nécessaire d'ajouter un nom pour cette colonne avant d'ajouter comme nom de colonne les noms des thèmes
        for col, theme in enumerate(themes, start=1):
            btn = QtWidgets.QPushButton("Tout (dé)sélectionner")
            btn.setToolTip(f"Tout cocher/décocher pour le thème « {theme} »")
            btn.clicked.connect(lambda _, c=col: self.toggle_column(c))
            self.tableThemes.setCellWidget(0, col, btn)

        # Ajoute les thèmes à la combobox (liste déroulante) des thèmes pour que l'utilisateur puisse sélectionner celui qu'il souhaite afficher
        if hasattr(self, "comboThemes"):
            self.comboThemes.clear()
            self.comboThemes.addItems(themes)

        # Parcourt chaque groupe/couche pour remplir la première colonne
        # Pour chaque groupe et chaque couche, une ligne est ajoutée aux éléments de la première colonne (Pour rappel : ["Groupe/Couche"])
        for row, (is_group, item_id, name, parent_id) in enumerate(items):
            item = QtWidgets.QTableWidgetItem(name)
            item.setFlags(item.flags() ^ QtCore.Qt.ItemIsEditable)  # Non éditable
            if is_group:
                font = item.font()
                font.setBold(True)  # Les groupes sont affichés en gras
                item.setFont(font)
            self.tableThemes.setItem(0, 0, QtWidgets.QTableWidgetItem(""))  # Ajoute un coin vide pour mettre en forme le tableau correctement
            item = QtWidgets.QTableWidgetItem("")
            item.setFlags(QtCore.Qt.ItemIsEnabled)  # Comme cette case est éditable, on désactive son édition
            self.tableThemes.setItem(0, 0, item)
            btn = QtWidgets.QPushButton("Tout (dé)sélectionner")
            btn.setToolTip(f"Tout cocher/décocher pour « {name} »")
            btn.clicked.connect(lambda _, r=row+1: self.toggle_row(r))
            self.tableThemes.setCellWidget(row + 1, 0, btn)

            # Pour chaque thème à afficher (sélection par filtrage avec la table_FilterAndSuppressThemes), une colonne est ajoutée à la tableThemes
            for col, theme in enumerate(themes, start=1): # La colonne 0 contient les groupes/couches, on commence à lister les thèmes à partir de la colonne d'indice 1
                if is_group:
                    # Si c'est un groupe, on le cherche par son nom et sa place dans l'arborescence car ils peuvent être imbriqués
                    def find_group_by_name(node, name):
                        for child in node.children(): 
                            if child.nodeType() == child.NodeGroup and child.name() == name:
                                return child
                            res = find_group_by_name(child, name)
                            if res:
                                return res
                        return None
                    group_node = find_group_by_name(root, item_id) # Le noued et l'item_id du group est récupéré depuis l'arbre des couches
                    checked = group_node.isVisible() if group_node else True # Est-il visible (coché)
                    chk = QtWidgets.QCheckBox() #Création des cases à cocher dans la QCheckBox
                    chk.setChecked(checked)
                    chk.setToolTip(
                        "Active ou désactive la visibilité du groupe dans l’arbre des couches.\n"
                        "Attention : ceci n'est pas stocké dans le thème QGIS, mais pour tout le projet."
                    ) # Au survol, permet d'afficher un message (hint) à destination de l'utilisateur
                    chk.is_group = is_group # Attribution des rôles aux cases à cocher chk exemple : chk.is_group apour rôle de gérer l'affichage des groupes
                    chk.item_id = item_id
                    chk.theme = theme
                    chk.stateChanged.connect(self._make_box_changed_handler(item_id, theme, is_group)) # Lorsque l'utilisateur agît sur l'état coché/décoché d'une case, un handler met à jour le thème
                else: # Si l'entité n'est pas un groupe (une couche)
                    # L'affichage d'une couche dépend de sa présence dans le thème
                    layers_in_theme = theme_collection.mapThemeVisibleLayerIds(theme)
                    checked = item_id in layers_in_theme # Vérification de la présence de la couche dans le thème
                    chk = QtWidgets.QCheckBox() # Création des cases à cocher et de leur rôle pour les couches
                    chk.setChecked(checked)
                    chk.is_group = is_group
                    chk.item_id = item_id
                    chk.theme = theme
                    chk.stateChanged.connect(self._make_box_changed_handler(item_id, theme, is_group))

                # Place la case à cocher au centre de la cellule
                widget = QtWidgets.QWidget()
                layout = QtWidgets.QHBoxLayout(widget)
                layout.addWidget(chk)
                layout.setAlignment(chk, QtCore.Qt.AlignCenter)
                layout.setContentsMargins(0, 0, 0, 0)
                widget.setLayout(layout)
                self.tableThemes.setCellWidget(row + 1, col, widget)
                self.tableThemes.resizeColumnsToContents() # Permet d'adapter la taille de la colonne en fonction du contenu

    def _make_box_changed_handler(self, item_id, theme, is_group):
        # Retourne une fonction handler qui appellera on_box_changed avec les bons paramètres
        def handler(state):
            self.on_box_changed(item_id, theme, state, is_group)
        return handler

    def on_box_changed(self, item_id, theme, state, is_group):
        # Appelée lorsqu'une case à cocher de la table principale est modifiée
        theme_collection = QgsProject.instance().mapThemeCollection()
        record = theme_collection.mapThemeState(theme)
        root = QgsProject.instance().layerTreeRoot()
        if is_group:
            # Lorsque c'est un groupe qui est coché, il est acivé dans l'arbre des couches
            def find_group_by_name(node, name):
                for child in node.children():
                    if child.nodeType() == child.NodeGroup and child.name() == name:
                        return child
                    res = find_group_by_name(child, name)
                    if res:
                        return res
                return None
            group_node = find_group_by_name(root, item_id)
            if not group_node:
                return
            group_node.setItemVisibilityChecked(state == QtCore.Qt.Checked)
        else:
            # Lorsque c'est une couche qui est cochée, elle est ajoutée au thème 
            # Peut-être ajouter plus tard que si la couche est cochée il faut mettre une alerte ou une sécurité automatique pour cocher le groupe qui contient la couche
            layer = QgsProject.instance().mapLayer(item_id)
            if not layer:
                return
            record.removeLayerRecord(layer)
            lr = QgsMapThemeCollection.MapThemeLayerRecord(layer)
            lr.isVisible = (state == QtCore.Qt.Checked)
            record.addLayerRecord(lr)
            theme_collection.update(theme, record)
            self.last_modified_theme = theme

    def fill_theme_filter_table(self):
        # Remplit la table de filtres/suppression des thèmes
        theme_collection = QgsProject.instance().mapThemeCollection()
        themes = list(theme_collection.mapThemes())
        # Évite de déclencher on_filter_changed pendant le remplissage (sinon erreur Python car ça va trop vite)
        self.table_FilterAndSuppressThemes.blockSignals(True)
        self.table_FilterAndSuppressThemes.setRowCount(len(themes))
        self.table_FilterAndSuppressThemes.setColumnCount(3)
        self.table_FilterAndSuppressThemes.setHorizontalHeaderLabels(["Afficher", "Thème", "Supprimer"])

        for row, theme in enumerate(themes):
            # Colonne 0 : case à cocher pour affichage du thème dans la table de choix des couches par thème
            chk_item = QtWidgets.QTableWidgetItem()
            chk_item.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
            chk_item.setCheckState(QtCore.Qt.Checked)
            self.table_FilterAndSuppressThemes.setItem(row, 0, chk_item)
            # Colonne 1 : Nom du thème (évidemment non éditable)
            name_item = QtWidgets.QTableWidgetItem(theme)
            name_item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_FilterAndSuppressThemes.setItem(row, 1, name_item)
            # Colonne 2 : Bouton permettant de supprimer ce thème, une QMessageBox est associé à cela plus tard dans le code pour une confirmation à l'utilisateur
            btn = QtWidgets.QPushButton("Supprimer")
            btn.clicked.connect(lambda checked, t=theme: self.delete_theme(t))
            self.table_FilterAndSuppressThemes.setCellWidget(row, 2, btn)

        self.table_FilterAndSuppressThemes.resizeColumnsToContents()
        self.table_FilterAndSuppressThemes.blockSignals(False)

    def create_new_theme(self):
        # Crée un nouveau thème à partir du texte entré par l'utilsiateur dans le PlainTextEdit
        if not hasattr(self, "textEditNameNewTheme"):
            return
        name = self.textEditNameNewTheme.toPlainText().strip()  # Récupère le nom du thème
        if not name:
            QtWidgets.QMessageBox.warning(self, "Nom manquant", "Veuillez saisir un nom de thème.") # Il est normalement impossible de ne pas entrer de texte car il a été définit par défaut dans Qt le texte : "Donner un nom à un nouveau thème"
            return
        theme_collection = QgsProject.instance().mapThemeCollection()
        if name in theme_collection.mapThemes():
            QtWidgets.QMessageBox.warning(self, "Thème existant", "Ce nom de thème existe déjà.") # Si le thème existe déjà
            return
        root = QgsProject.instance().layerTreeRoot()
        # Récupère le modèle d'arbre des couches depuis l'interface QGIS
        layerTreeModel = self.iface.layerTreeView().layerTreeModel()
        # Variable stockant l'état actuel de l'arbre des couches pour la création du nouveau thème
        # Peut-être plus tard créer une nouvelle fenêtre ui dans Qt qui s'ouvre lorsque l'utilisateur veut créer un thème et qui lui propose de cocher les couches à afficher dans ce thème
        theme_state = QgsMapThemeCollection.createThemeFromCurrentState(root, layerTreeModel)
        # Insère le nouveau thème dans la collection des thèmes éxistants
        theme_collection.insert(name, theme_state)
        # Rafraîchit les deux tables pour afficher le nouveau thème
        self.fill_theme_filter_table()
        self.fill_theme_table()
        self.textEditNameNewTheme.clear()  # Vide le champ texte pour ne pas cliquer sur le bouton à nouveau et obtenir l'erreur "Un thème existant porte déjà ce nom (même si celle "Entrer un nom" va apparaître)"

    def delete_theme(self, theme_name):
        # Supprime un thème
        theme_collection = QgsProject.instance().mapThemeCollection()
        if theme_name not in theme_collection.mapThemes():
            return
        # Demande confirmation à l'utilisateur
        reply = QtWidgets.QMessageBox.question(
            self, "Suppresion de thème",
            f"Êtes-vous sûr de vouloir supprimer le thème : « {theme_name} » ?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            theme_collection.removeMapTheme(theme_name)  # Supprime le thème
            self.fill_theme_filter_table()
            self.fill_theme_table()

    def on_filter_changed(self, item):
        # Rafraîchit la table principale si un filtre est coché/décoché
        if item.column() == 0:  # Si c'est une case à cocher
            self.fill_theme_table()  # Rafraîchit la table principale

    def apply_selected_theme(self):
    # Applique le thème sélectionné dans la combo box (en lien avec le btnApplyTheme)
        if hasattr(self, "comboThemes"):
            selected_theme = self.comboThemes.currentText()
        if selected_theme:
            theme_collection = QgsProject.instance().mapThemeCollection()
            root = QgsProject.instance().layerTreeRoot()
            layerTreeModel = self.iface.layerTreeView().layerTreeModel()
            theme_collection.applyTheme(selected_theme, root, layerTreeModel)

    def toggle_row(self, row):
        for col in range(1, self.tableThemes.columnCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk:
                    chk.setChecked(not chk.isChecked())

    def toggle_column(self, col):
        for row in range(1, self.tableThemes.rowCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk:
                    chk.setChecked(not chk.isChecked())
