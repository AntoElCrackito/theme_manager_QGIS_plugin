# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThemeManagerDialog
                                 A QGIS plugin
 This plugin stands to be a theme manager. It allows you to select the layers you want to set up in the different themes in your projet as a checklist, showing up all themes at once.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-22
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Antoine BOYER
        email                : @
 ***************************************************************************/
"""

import os
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtCore
from qgis.core import QgsProject, QgsMapThemeCollection

# Charge le formulaire .ui généré dans QtDesigner
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'theme_manager_dialog_base.ui'))

class ThemeManagerDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None): # Initialisation de l'interface utilisateur : Connection aux boutons principaux et remplissage des tableaux à l'ouverture
        super().__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.last_modified_theme = None

        # Connecte les boutons principaux à leurs méthodes
        if hasattr(self, "btnCreateNewTheme"):
            self.btnCreateNewTheme.clicked.connect(self.create_new_theme)
        if hasattr(self, "btnApplyTheme"):
            self.btnApplyTheme.clicked.connect(self.apply_selected_theme)
        if hasattr(self, "table_FilterAndSuppressThemes"):
            self.table_FilterAndSuppressThemes.itemChanged.connect(self.on_filter_changed)

        # Remplis les deux tables à l’ouverture (couches/thèmes et filtres)
        self.fill_theme_table()
        self.fill_theme_filter_table()

    # Construit et remplit la table principale (groupes/couches vs thèmes).
    def fill_theme_table(self):
        theme_collection = QgsProject.instance().mapThemeCollection()
        all_themes = list(theme_collection.mapThemes())

        for col in range(2, self.tableThemes.columnCount()):
            self.tableThemes.setColumnWidth(col, 140)  # Ajuste pour lisibilité

        # On affiche que les thèmes cochés dans la table de filtre, sinon tous
        if hasattr(self, "table_FilterAndSuppressThemes"):
            selected_themes = []
            for row in range(self.table_FilterAndSuppressThemes.rowCount()):
                if self.table_FilterAndSuppressThemes.item(row, 0).checkState() == QtCore.Qt.Checked:
                    selected_themes.append(self.table_FilterAndSuppressThemes.item(row, 1).text())
            themes = selected_themes if selected_themes else all_themes
        else:
            themes = all_themes

        # Liste tous les groupes et couches de l’arbre des couches
        items = []
        def add_items_rec(node, parent_id=None):
            for child in node.children():
                if child.nodeType() == child.NodeGroup:
                    group_id = child.name()
                    items.append((True, group_id, child.name(), parent_id))
                    add_items_rec(child, group_id)
                elif child.nodeType() == child.NodeLayer:
                    items.append((False, child.layerId(), child.name(), parent_id))
        root = QgsProject.instance().layerTreeRoot()
        add_items_rec(root)

        # Prépare la table : première ligne = boutons colonne, première colonne = boutons ligne
        self.tableThemes.clear()
        self.tableThemes.setRowCount(len(items) + 1)
        self.tableThemes.setColumnCount(len(themes) + 2)
        self.tableThemes.setHorizontalHeaderLabels(["", "Groupe/Couche"] + themes)
        for col in [0, 1]:
            item = QtWidgets.QTableWidgetItem()
            item.setFlags(QtCore.Qt.ItemIsEnabled)
            item.setBackground(QtCore.Qt.gray)
            self.tableThemes.setItem(0, col, item)

        # Boutons d'action colonne (par thème)
        from functools import partial
        for col, theme in enumerate(themes, start=2):
            header_widget = QtWidgets.QWidget()
            header_layout = QtWidgets.QVBoxLayout(header_widget)
            header_layout.setContentsMargins(0, 0, 0, 0)
            header_layout.setSpacing(2)

            btn_select_all = QtWidgets.QPushButton("Tout sélectionner")
            btn_select_all.setToolTip(f"Tout cocher pour le thème « {theme} »")
            btn_select_all.clicked.connect(partial(self.select_all_column, col))
            header_layout.addWidget(btn_select_all)

            btn_invert = QtWidgets.QPushButton("Inverser la sélection")
            btn_invert.setToolTip(f"Inverser la sélection pour le thème « {theme} »")
            btn_invert.clicked.connect(partial(self.invert_column, col))
            header_layout.addWidget(btn_invert)

            self.tableThemes.setCellWidget(0, col, header_widget)

        # ComboBox des thèmes (pour appliquer un thème complet)
        if hasattr(self, "comboThemes"):
            self.comboThemes.clear()
            self.comboThemes.addItems(themes)

        # Remplit chaque ligne de la table
        for row, (is_group, item_id, name, parent_id) in enumerate(items):
            # Colonne 0 : boutons d’action ligne (tout sélectionner/inverser)
            btn_widget = QtWidgets.QWidget()
            btn_layout = QtWidgets.QVBoxLayout(btn_widget)
            btn_layout.setContentsMargins(0, 0, 0, 0)
            btn_layout.setSpacing(2)

            btn_select_all_row = QtWidgets.QPushButton("Tout sélectionner")
            btn_select_all_row.setToolTip(f"Tout cocher pour « {name} »")
            btn_select_all_row.clicked.connect(partial(self.select_all_row, row + 1))
            btn_layout.addWidget(btn_select_all_row)

            btn_invert_row = QtWidgets.QPushButton("Inverser la sélection")
            btn_invert_row.setToolTip(f"Inverser la sélection pour « {name} »")
            btn_invert_row.clicked.connect(partial(self.invert_row, row + 1))
            btn_layout.addWidget(btn_invert_row)

            self.tableThemes.setCellWidget(row + 1, 0, btn_widget)

            # Colonne 1 : nom du groupe/couche (gras si groupe)
            label = QtWidgets.QLabel(name)
            if is_group:
                font = label.font()
                font.setBold(True)
                label.setFont(font)
            self.tableThemes.setCellWidget(row + 1, 1, label)

            # Colonnes suivantes : cases à cocher par thème
            for col, theme in enumerate(themes, start=2):
                if is_group:
                    def find_group_by_name(node, name):
                        for child in node.children():
                            if child.nodeType() == child.NodeGroup and child.name() == name:
                                return child
                            res = find_group_by_name(child, name)
                            if res:
                                return res
                        return None
                    group_node = find_group_by_name(root, item_id)
                    checked = group_node.isVisible() if group_node else True
                    chk = QtWidgets.QCheckBox()
                    chk.setChecked(checked)
                    chk.setToolTip("Active la visibilité du groupe dans l’arbre des couches (n’est pas stockée dans le thème QGIS)")
                    chk.is_group = is_group
                    chk.item_id = item_id
                    chk.theme = theme
                    chk.stateChanged.connect(partial(self.on_box_changed, item_id, theme, is_group))
                else:
                    layers_in_theme = theme_collection.mapThemeVisibleLayerIds(theme)
                    checked = item_id in layers_in_theme
                    chk = QtWidgets.QCheckBox()
                    chk.setChecked(checked)
                    chk.is_group = is_group
                    chk.item_id = item_id
                    chk.theme = theme
                    chk.stateChanged.connect(partial(self.on_box_changed, item_id, theme, is_group))

                widget = QtWidgets.QWidget()
                layout = QtWidgets.QHBoxLayout(widget)
                layout.addWidget(chk)
                layout.setAlignment(chk, QtCore.Qt.AlignCenter)
                layout.setContentsMargins(0, 0, 0, 0)
                widget.setLayout(layout)
                self.tableThemes.setCellWidget(row + 1, col, widget)
        self.tableThemes.resizeColumnsToContents()

        self.tableThemes.resizeRowsToContents()
        self.tableThemes.resizeColumnsToContents()
        self.tableThemes.resizeRowsToContents()
        self.tableThemes.resizeColumnsToContents()
        
    # Appelée lorsqu'une case à cocher de la table principale est modifiée
    def on_box_changed(self, item_id, theme, is_group, state):
        theme_collection = QgsProject.instance().mapThemeCollection()
        record = theme_collection.mapThemeState(theme)
        root = QgsProject.instance().layerTreeRoot()
        if is_group:
            def find_group_by_name(node, name):
                for child in node.children():
                    if child.nodeType() == child.NodeGroup and child.name() == name:
                        return child
                    res = find_group_by_name(child, name)
                    if res:
                        return res
                return None
            group_node = find_group_by_name(root, item_id)
            if group_node:
                group_node.setItemVisibilityChecked(state == QtCore.Qt.Checked)
        else:
            layer = QgsProject.instance().mapLayer(item_id)
            if layer:
                if state == QtCore.Qt.Checked:
                    # Ajoute la couche visible dans le thème
                    record.removeLayerRecord(layer)
                    lr = QgsMapThemeCollection.MapThemeLayerRecord(layer)
                    lr.isVisible = True
                    record.addLayerRecord(lr)
                else:
                    # Retire la couche du thème
                    record.removeLayerRecord(layer)
                theme_collection.update(theme, record)
                self.last_modified_theme = theme

        # Synchronise la visibilité des groupes
        self.check_group_if_layers_in_check()

        # Applique le thème courant si tu veux voir l’effet instantané (comboThemes doit être à jour)
        if hasattr(self, "comboThemes"):
            current_theme = self.comboThemes.currentText()
            if current_theme:
                theme_collection.applyTheme(current_theme, root, self.iface.layerTreeView().layerTreeModel())

    # Cette méthode est appelée quand on clique sur le bouton "Appliquer le thème sélectionné"
    def apply_selected_theme(self):
        # Vérifie si l'objet comboThemes (la liste déroulante des thèmes) existe bien dans le formulaire
        if hasattr(self, "comboThemes"):
            # Récupère le nom du thème actuellement sélectionné dans la combo box
            selected_theme = self.comboThemes.currentText()
        else:
            # Si la combo box n'existe pas, on met selected_theme à None (cas très rare)
            selected_theme = None
        # Si un thème est bien sélectionné (le nom n'est pas vide)
        if selected_theme:
            # Récupère la collection des thèmes du projet QGIS courant
            theme_collection = QgsProject.instance().mapThemeCollection()
            # Récupère la racine de l'arbre des couches du projet
            root = QgsProject.instance().layerTreeRoot()
            # Récupère le modèle d'arbre des couches utilisé par l'interface
            layerTreeModel = self.iface.layerTreeView().layerTreeModel()
            # Applique l'état d'affichage du thème sélectionné à l'ensemble du projet
            theme_collection.applyTheme(selected_theme, root, layerTreeModel)
            # Met à jour la visibilité des groupes en fonction des couches visibles
            self.check_group_if_layers_in_check()

    # Remplit la table de gestion des thèmes (affichage/suppression).
    def fill_theme_filter_table(self):
        theme_collection = QgsProject.instance().mapThemeCollection()
        themes = list(theme_collection.mapThemes())
        self.table_FilterAndSuppressThemes.blockSignals(True)
        self.table_FilterAndSuppressThemes.setRowCount(len(themes))
        self.table_FilterAndSuppressThemes.setColumnCount(4)  # 1 colonne de plus pour "Modifier le nom"
        self.table_FilterAndSuppressThemes.setHorizontalHeaderLabels(["Afficher", "Thème", "Supprimer", "Modifier le nom"])

        for row, theme in enumerate(themes):
            chk_item = QtWidgets.QTableWidgetItem()
            chk_item.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
            chk_item.setCheckState(QtCore.Qt.Checked)
            self.table_FilterAndSuppressThemes.setItem(row, 0, chk_item)
            name_item = QtWidgets.QTableWidgetItem(theme)
            name_item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.table_FilterAndSuppressThemes.setItem(row, 1, name_item)
            # Bouton supprimer
            btn = QtWidgets.QPushButton("Supprimer")
            btn.clicked.connect(lambda checked, t=theme: self.delete_theme(t))
            self.table_FilterAndSuppressThemes.setCellWidget(row, 2, btn)
            # Bouton modifier le nom
            btn_rename = QtWidgets.QPushButton("Modifier le nom du thème")
            btn_rename.setToolTip("Renommer ce thème")
            btn_rename.clicked.connect(lambda checked, t=theme, r=row: self.rename_theme_from_table(t, r))
            self.table_FilterAndSuppressThemes.setCellWidget(row, 3, btn_rename)

        self.table_FilterAndSuppressThemes.resizeColumnsToContents()
        self.table_FilterAndSuppressThemes.blockSignals(False)

    def rename_theme_from_table(self, old_name, row):
        theme_collection = QgsProject.instance().mapThemeCollection()
        # Demande un nouveau nom à l'utilisateur
        new_name, ok = QtWidgets.QInputDialog.getText(self, "Renommer le thème",
            f"Entrer un nouveau nom pour le thème « {old_name} » :", QtWidgets.QLineEdit.Normal, old_name)
        if not ok or not new_name:
            return 
        new_name = new_name.strip()
        # Vérification du nom (QGIS refuse les chaînes vides, doublons, caractères spéciaux ...)
        if not new_name:
            QtWidgets.QMessageBox.warning(self, "Nom manquant", "Veuillez saisir un nom de thème non vide.")
            return
        if new_name == old_name:
            QtWidgets.QMessageBox.information(self, "Renommer le thème", "Le nom n'a pas changé.")
            return
        if new_name in theme_collection.mapThemes():
            QtWidgets.QMessageBox.warning(self, "Thème existant", "Ce nom de thème existe déjà.")
            return
        # Optionnel : tu peux ajouter d'autres vérifications si besoin (caractères interdits)
        # Renommage effectif
        theme_collection.renameMapTheme(old_name, new_name)
        self.fill_theme_filter_table()
        self.fill_theme_table()
        QtWidgets.QMessageBox.information(self, "Renommé", f"Le thème « {old_name} » a été renommé en « {new_name} ».")

    # Crée un nouveau thème à partir du nom saisi.
    def create_new_theme(self):
        if not hasattr(self, "textEditNameNewTheme"):
            return
        name = self.textEditNameNewTheme.toPlainText().strip()
        if not name:
            QtWidgets.QMessageBox.warning(self, "Nom manquant", "Veuillez saisir un nom de thème.")
            return
        theme_collection = QgsProject.instance().mapThemeCollection()
        if name in theme_collection.mapThemes():
            QtWidgets.QMessageBox.warning(self, "Thème existant", "Ce nom de thème existe déjà.")
            return
        root = QgsProject.instance().layerTreeRoot()
        layerTreeModel = self.iface.layerTreeView().layerTreeModel()
        theme_state = QgsMapThemeCollection.createThemeFromCurrentState(root, layerTreeModel)
        theme_collection.insert(name, theme_state)
        self.fill_theme_filter_table()
        self.fill_theme_table()
        self.textEditNameNewTheme.clear()

    # Supprime un thème après confirmation.
    def delete_theme(self, theme_name):
        theme_collection = QgsProject.instance().mapThemeCollection()
        if theme_name not in theme_collection.mapThemes():
            return
        reply = QtWidgets.QMessageBox.question(
            self, "Suppression de thème",
            f"Êtes-vous sûr de vouloir supprimer le thème : « {theme_name} » ?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            theme_collection.removeMapTheme(theme_name)
            self.fill_theme_filter_table()
            self.fill_theme_table()

    def on_filter_changed(self, item):
        if item.column() == 0:
            self.fill_theme_table()
        elif item.column() == 1:
            row = item.row()
            old_name = self._get_theme_name_by_row(row)
            new_name = item.text().strip()
            if not new_name or new_name == old_name:
                return
            theme_collection = QgsProject.instance().mapThemeCollection()
            if new_name in theme_collection.mapThemes():
                QtWidgets.QMessageBox.warning(self, "Thème existant", "Ce nom de thème existe déjà.")
                item.setText(old_name)
                return
            theme_collection.renameMapTheme(old_name, new_name)
            self.fill_theme_filter_table()
            self.fill_theme_table()

    def _get_theme_name_by_row(self, row):
        item = self.table_FilterAndSuppressThemes.item(row, 1)
        return item.text() if item else ""

    def select_all_row(self, row):
        for col in range(2, self.tableThemes.columnCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk and not chk.isChecked():
                    chk.setChecked(True)

    def invert_row(self, row):
        for col in range(2, self.tableThemes.columnCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk:
                    chk.setChecked(not chk.isChecked())

    def select_all_column(self, col):
        # Coche toutes les cases de la colonne (thème)
        for row in range(1, self.tableThemes.rowCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk and not chk.isChecked():
                    chk.setChecked(True)

    # Inverse l'état de coche des cases dans la colonne (thème)
    def invert_column(self, col):
        for row in range(1, self.tableThemes.rowCount()):
            cell_widget = self.tableThemes.cellWidget(row, col)
            if cell_widget:
                chk = cell_widget.findChild(QtWidgets.QCheckBox)
                if chk:
                    chk.setChecked(not chk.isChecked())

    # Force la visibilité des groupes si au moins une couche/groupe enfant est visible.
    def check_group_if_layers_in_check(self):
        root = QgsProject.instance().layerTreeRoot()
        def update_group(node):
            if node.nodeType() == node.NodeGroup:
                any_child_visible = False
                for child in node.children():
                    if child.nodeType() == child.NodeLayer and child.isVisible():
                        any_child_visible = True
                    elif child.nodeType() == child.NodeGroup and update_group(child):
                        any_child_visible = True
                node.setItemVisibilityChecked(any_child_visible)
                return any_child_visible
            elif node.nodeType() == node.NodeLayer:
                return node.isVisible()
            return False
        update_group(root)